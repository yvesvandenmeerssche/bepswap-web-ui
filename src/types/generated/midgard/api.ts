// tslint:disable
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssetDetail
 */
export interface AssetDetail {
    /**
     * 
     * @type {string}
     * @memberof AssetDetail
     */
    asset?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetDetail
     */
    dateCreated?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetDetail
     */
    priceRune?: string;
}
/**
 * 
 * @export
 * @interface BlockRewards
 */
export interface BlockRewards {
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    blockReward?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    bondReward?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    stakeReward?: string;
}
/**
 * 
 * @export
 * @interface BondMetrics
 */
export interface BondMetrics {
    /**
     * Average bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageActiveBond?: string;
    /**
     * Average bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageStandbyBond?: string;
    /**
     * Maxinum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumActiveBond?: string;
    /**
     * Maximum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumStandbyBond?: string;
    /**
     * Median bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianActiveBond?: string;
    /**
     * Median bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianStandbyBond?: string;
    /**
     * Minumum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumActiveBond?: string;
    /**
     * Minumum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumStandbyBond?: string;
    /**
     * Total bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalActiveBond?: string;
    /**
     * Total bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalStandbyBond?: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    asset?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    fee?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    slip?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    stakeUnits?: string;
}
/**
 * 
 * @export
 * @interface Gas
 */
export interface Gas {
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    asset?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    catchingUp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    database?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    scannerHeight?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count?: number;
    /**
     * 
     * @type {Array<TxDetails>}
     * @memberof InlineResponse2001
     */
    txs?: Array<TxDetails>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    error: string;
}
/**
 * 
 * @export
 * @interface NetworkInfo
 */
export interface NetworkInfo {
    /**
     * Array of Active Bonds
     * @type {Array<string>}
     * @memberof NetworkInfo
     */
    activeBonds?: Array<string>;
    /**
     * Number of Active Nodes
     * @type {number}
     * @memberof NetworkInfo
     */
    activeNodeCount?: number;
    /**
     * 
     * @type {BlockRewards}
     * @memberof NetworkInfo
     */
    blockRewards?: BlockRewards;
    /**
     * 
     * @type {BondMetrics}
     * @memberof NetworkInfo
     */
    bondMetrics?: BondMetrics;
    /**
     * (1 + (bondReward * blocksPerMonth/totalActiveBond)) ^ 12 -1
     * @type {string}
     * @memberof NetworkInfo
     */
    bondingAPY?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    bondingROI?: string;
    /**
     * (1 + (stakeReward * blocksPerMonth/totalDepth of active pools)) ^ 12 -1
     * @type {string}
     * @memberof NetworkInfo
     */
    liquidityAPY?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    nextChurnHeight?: string;
    /**
     * The remaining time of pool activation (in blocks)
     * @type {number}
     * @memberof NetworkInfo
     */
    poolActivationCountdown?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    poolShareFactor?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    stakingROI?: string;
    /**
     * Array of Standby Bonds
     * @type {Array<string>}
     * @memberof NetworkInfo
     */
    standbyBonds?: Array<string>;
    /**
     * Number of Standby Nodes
     * @type {number}
     * @memberof NetworkInfo
     */
    standbyNodeCount?: number;
    /**
     * Total left in Reserve
     * @type {string}
     * @memberof NetworkInfo
     */
    totalReserve?: string;
    /**
     * Total Rune Staked in Pools
     * @type {string}
     * @memberof NetworkInfo
     */
    totalStaked?: string;
}
/**
 * 
 * @export
 * @interface NodeKey
 */
export interface NodeKey {
    /**
     * ed25519 public key
     * @type {string}
     * @memberof NodeKey
     */
    ed25519?: string;
    /**
     * secp256k1 public key
     * @type {string}
     * @memberof NodeKey
     */
    secp256k1?: string;
}
/**
 * 
 * @export
 * @interface Option
 */
export interface Option {
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    asymmetry?: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    priceTarget?: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    withdrawBasisPoints?: string;
}
/**
 * 
 * @export
 * @interface PoolAggChanges
 */
export interface PoolAggChanges {
    /**
     * Total changes in asset depth at this time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetChanges?: string;
    /**
     * Depth of asset at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetDepth?: string;
    /**
     * Total asset staked
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetStaked?: string;
    /**
     * Total asset withdrawn
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetWithdrawn?: string;
    /**
     * Count of buy swaps
     * @type {number}
     * @memberof PoolAggChanges
     */
    buyCount?: number;
    /**
     * Sum of \"rune_amount\" of buy swap events
     * @type {string}
     * @memberof PoolAggChanges
     */
    buyVolume?: string;
    /**
     * Total amount of rune, paid by the network to neutralize \"gasUsed\" changes
     * @type {string}
     * @memberof PoolAggChanges
     */
    gasReplenished?: string;
    /**
     * Total amount of asset used as gas for network transactions (e.g. BNB.BNB, ETH.ETH)
     * @type {string}
     * @memberof PoolAggChanges
     */
    gasUsed?: string;
    /**
     * buyVolume + sellVolume
     * @type {string}
     * @memberof PoolAggChanges
     */
    poolVolume?: string;
    /**
     * Asset price in rune at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    price?: string;
    /**
     * Sum of \"rewards\" events in rune
     * @type {string}
     * @memberof PoolAggChanges
     */
    reward?: string;
    /**
     * Total changes in rune depth at this time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeChanges?: string;
    /**
     * Depth of rune at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeDepth?: string;
    /**
     * Total rune staked
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeStaked?: string;
    /**
     * Total rune withdrawn
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeWithdrawn?: string;
    /**
     * Count of sell swaps
     * @type {number}
     * @memberof PoolAggChanges
     */
    sellCount?: number;
    /**
     * Sum of \"rune_amount\" of sell swap events
     * @type {string}
     * @memberof PoolAggChanges
     */
    sellVolume?: string;
    /**
     * Count of stake events
     * @type {number}
     * @memberof PoolAggChanges
     */
    stakeCount?: number;
    /**
     * Determining end of current time bucket in unix timestamp
     * @type {number}
     * @memberof PoolAggChanges
     */
    time?: number;
    /**
     * Total changes in pool units (stakes/withdraws)
     * @type {string}
     * @memberof PoolAggChanges
     */
    unitsChanges?: string;
    /**
     * Count of withdraw events
     * @type {number}
     * @memberof PoolAggChanges
     */
    withdrawCount?: number;
}
/**
 * 
 * @export
 * @interface PoolDetail
 */
export interface PoolDetail {
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    asset?: string;
    /**
     * Total current Asset balance
     * @type {string}
     * @memberof PoolDetail
     */
    assetDepth?: string;
    /**
     * Amount of pool asset changed by fee and gas
     * @type {string}
     * @memberof PoolDetail
     */
    assetEarned?: string;
    /**
     * Asset return on investment
     * @type {string}
     * @memberof PoolDetail
     */
    assetROI?: string;
    /**
     * Total Asset staked
     * @type {string}
     * @memberof PoolDetail
     */
    assetStakedTotal?: string;
    /**
     * Number of RUNE->ASSET transactions
     * @type {string}
     * @memberof PoolDetail
     */
    buyAssetCount?: string;
    /**
     * Average sell Asset fee size for RUNE->ASSET (in ASSET)
     * @type {string}
     * @memberof PoolDetail
     */
    buyFeeAverage?: string;
    /**
     * Total fees (in Asset)
     * @type {string}
     * @memberof PoolDetail
     */
    buyFeesTotal?: string;
    /**
     * Average trade slip for RUNE->ASSET in %
     * @type {string}
     * @memberof PoolDetail
     */
    buySlipAverage?: string;
    /**
     * Average Asset buy transaction size for (RUNE->ASSET) (in ASSET)
     * @type {string}
     * @memberof PoolDetail
     */
    buyTxAverage?: string;
    /**
     * Total Asset buy volume (RUNE->ASSET) (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    buyVolume?: string;
    /**
     * (1 + (poolEarned/poolDepth)) ^ 12 -1
     * @type {string}
     * @memberof PoolDetail
     */
    poolAPY?: string;
    /**
     * Total depth of both sides (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolDepth?: string;
    /**
     * (assetChanges * price) + runeEarned
     * @type {string}
     * @memberof PoolDetail
     */
    poolEarned?: string;
    /**
     * Average pool fee
     * @type {string}
     * @memberof PoolDetail
     */
    poolFeeAverage?: string;
    /**
     * Total fees
     * @type {string}
     * @memberof PoolDetail
     */
    poolFeesTotal?: string;
    /**
     * Pool ROI (average of RUNE and Asset ROI)
     * @type {string}
     * @memberof PoolDetail
     */
    poolROI?: string;
    /**
     * Pool ROI over 12 months
     * @type {string}
     * @memberof PoolDetail
     */
    poolROI12?: string;
    /**
     * Average pool slip
     * @type {string}
     * @memberof PoolDetail
     */
    poolSlipAverage?: string;
    /**
     * Rune value staked Total
     * @type {string}
     * @memberof PoolDetail
     */
    poolStakedTotal?: string;
    /**
     * Average pool transaction
     * @type {string}
     * @memberof PoolDetail
     */
    poolTxAverage?: string;
    /**
     * Total pool units outstanding
     * @type {string}
     * @memberof PoolDetail
     */
    poolUnits?: string;
    /**
     * Two-way volume of all-time (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolVolume?: string;
    /**
     * Two-way volume in 24hrs (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolVolume24hr?: string;
    /**
     * Price of Asset (in RUNE).
     * @type {string}
     * @memberof PoolDetail
     */
    price?: string;
    /**
     * Total current Rune balance
     * @type {string}
     * @memberof PoolDetail
     */
    runeDepth?: string;
    /**
     * Amount of pool rune changed by fee,reward and gas
     * @type {string}
     * @memberof PoolDetail
     */
    runeEarned?: string;
    /**
     * RUNE return on investment
     * @type {string}
     * @memberof PoolDetail
     */
    runeROI?: string;
    /**
     * Total RUNE staked
     * @type {string}
     * @memberof PoolDetail
     */
    runeStakedTotal?: string;
    /**
     * Number of ASSET->RUNE transactions
     * @type {string}
     * @memberof PoolDetail
     */
    sellAssetCount?: string;
    /**
     * Average buy Asset fee size for ASSET->RUNE (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellFeeAverage?: string;
    /**
     * Total fees (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellFeesTotal?: string;
    /**
     * Average trade slip for ASSET->RUNE in %
     * @type {string}
     * @memberof PoolDetail
     */
    sellSlipAverage?: string;
    /**
     * Average Asset sell transaction size (ASSET>RUNE) (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellTxAverage?: string;
    /**
     * Total Asset sell volume (ASSET>RUNE) (in RUNE).
     * @type {string}
     * @memberof PoolDetail
     */
    sellVolume?: string;
    /**
     * Number of stake transactions
     * @type {string}
     * @memberof PoolDetail
     */
    stakeTxCount?: string;
    /**
     * Number of unique stakers
     * @type {string}
     * @memberof PoolDetail
     */
    stakersCount?: string;
    /**
     * Number of stake & withdraw transactions
     * @type {string}
     * @memberof PoolDetail
     */
    stakingTxCount?: string;
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    status?: PoolDetailStatusEnum;
    /**
     * Number of unique swappers interacting with pool
     * @type {string}
     * @memberof PoolDetail
     */
    swappersCount?: string;
    /**
     * Number of swapping transactions in the pool (buys and sells)
     * @type {string}
     * @memberof PoolDetail
     */
    swappingTxCount?: string;
    /**
     * Number of withdraw transactions
     * @type {string}
     * @memberof PoolDetail
     */
    withdrawTxCount?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PoolDetailStatusEnum {
    Bootstrapped = 'bootstrapped',
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface StakersAddressData
 */
export interface StakersAddressData {
    /**
     * 
     * @type {Array<string>}
     * @memberof StakersAddressData
     */
    poolsArray?: Array<string>;
    /**
     * Total value of earnings (in RUNE) across all pools.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalEarned?: string;
    /**
     * Average of all pool ROIs.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalROI?: string;
    /**
     * Total staked (in RUNE) across all pools.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalStaked?: string;
}
/**
 * 
 * @export
 * @interface StakersAssetData
 */
export interface StakersAssetData {
    /**
     * 
     * @type {string}
     * @memberof StakersAssetData
     */
    asset?: string;
    /**
     * Total of assets staked
     * @type {string}
     * @memberof StakersAssetData
     */
    assetStaked?: string;
    /**
     * Total of assets withdrawn
     * @type {string}
     * @memberof StakersAssetData
     */
    assetWithdrawn?: string;
    /**
     * 
     * @type {number}
     * @memberof StakersAssetData
     */
    dateFirstStaked?: number;
    /**
     * 
     * @type {number}
     * @memberof StakersAssetData
     */
    heightLastStaked?: number;
    /**
     * Total of rune staked
     * @type {string}
     * @memberof StakersAssetData
     */
    runeStaked?: string;
    /**
     * Total of rune withdrawn
     * @type {string}
     * @memberof StakersAssetData
     */
    runeWithdrawn?: string;
    /**
     * Represents ownership of a pool.
     * @type {string}
     * @memberof StakersAssetData
     */
    units?: string;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * Daily active users (unique addresses interacting)
     * @type {string}
     * @memberof StatsData
     */
    dailyActiveUsers?: string;
    /**
     * Daily transactions
     * @type {string}
     * @memberof StatsData
     */
    dailyTx?: string;
    /**
     * Monthly active users
     * @type {string}
     * @memberof StatsData
     */
    monthlyActiveUsers?: string;
    /**
     * Monthly transactions
     * @type {string}
     * @memberof StatsData
     */
    monthlyTx?: string;
    /**
     * Number of active pools
     * @type {string}
     * @memberof StatsData
     */
    poolCount?: string;
    /**
     * Total buying transactions
     * @type {string}
     * @memberof StatsData
     */
    totalAssetBuys?: string;
    /**
     * Total selling transactions
     * @type {string}
     * @memberof StatsData
     */
    totalAssetSells?: string;
    /**
     * Total RUNE balances
     * @type {string}
     * @memberof StatsData
     */
    totalDepth?: string;
    /**
     * Total earned (in RUNE Value).
     * @type {string}
     * @memberof StatsData
     */
    totalEarned?: string;
    /**
     * Total staking transactions
     * @type {string}
     * @memberof StatsData
     */
    totalStakeTx?: string;
    /**
     * Total staked (in RUNE Value).
     * @type {string}
     * @memberof StatsData
     */
    totalStaked?: string;
    /**
     * Total transactions
     * @type {string}
     * @memberof StatsData
     */
    totalTx?: string;
    /**
     * Total unique swappers & stakers
     * @type {string}
     * @memberof StatsData
     */
    totalUsers?: string;
    /**
     * Total (in RUNE Value) of all assets swapped since start.
     * @type {string}
     * @memberof StatsData
     */
    totalVolume?: string;
    /**
     * Total (in RUNE Value) of all assets swapped in 24hrs
     * @type {string}
     * @memberof StatsData
     */
    totalVolume24hr?: string;
    /**
     * Total withdrawing transactions
     * @type {string}
     * @memberof StatsData
     */
    totalWithdrawTx?: string;
}
/**
 * 
 * @export
 * @interface ThorchainBooleanConstants
 */
export interface ThorchainBooleanConstants {
    /**
     * 
     * @type {boolean}
     * @memberof ThorchainBooleanConstants
     */
    strictBondStakeRatio?: boolean;
}
/**
 * 
 * @export
 * @interface ThorchainConstants
 */
export interface ThorchainConstants {
    /**
     * 
     * @type {ThorchainBooleanConstants}
     * @memberof ThorchainConstants
     */
    boolValues?: ThorchainBooleanConstants;
    /**
     * 
     * @type {ThorchainInt64Constants}
     * @memberof ThorchainConstants
     */
    int64Values?: ThorchainInt64Constants;
    /**
     * 
     * @type {ThorchainStringConstants}
     * @memberof ThorchainConstants
     */
    stringValues?: ThorchainStringConstants;
}
/**
 * 
 * @export
 * @interface ThorchainEndpoint
 */
export interface ThorchainEndpoint {
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    chain?: string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    pubKey?: string;
}
/**
 * 
 * @export
 * @interface ThorchainEndpoints
 */
export interface ThorchainEndpoints {
    /**
     * 
     * @type {Array<ThorchainEndpoint>}
     * @memberof ThorchainEndpoints
     */
    current?: Array<ThorchainEndpoint>;
}
/**
 * 
 * @export
 * @interface ThorchainInt64Constants
 */
export interface ThorchainInt64Constants {
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    badValidatorRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    blocksPerYear?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    desireValidatorSet?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    doubleSignMaxAge?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    emissionCurve?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    failKeySignSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    failKeygenSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    fundMigrationInterval?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    jailTimeKeygen?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    jailTimeKeysign?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    lackOfObservationPenalty?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    minimumBondInRune?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    minimumNodesForBFT?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    minimumNodesForYggdrasil?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    newPoolCycle?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    observeSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    oldValidatorRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    rotatePerBlockHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    rotateRetryBlocks?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    signingTransactionPeriod?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    stakeLockUpBlocks?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    transactionFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    validatorRotateInNumBeforeFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    validatorRotateNumAfterFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    validatorRotateOutNumBeforeFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    whiteListGasAsset?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    yggFundLimit?: number;
}
/**
 * 
 * @export
 * @interface ThorchainLastblock
 */
export interface ThorchainLastblock {
    /**
     * 
     * @type {string}
     * @memberof ThorchainLastblock
     */
    chain?: string;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    lastobservedin?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    lastsignedout?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    thorchain?: number;
}
/**
 * 
 * @export
 * @interface ThorchainStringConstants
 */
export interface ThorchainStringConstants {
    /**
     * 
     * @type {string}
     * @memberof ThorchainStringConstants
     */
    defaultPoolStatus?: string;
}
/**
 * 
 * @export
 * @interface TotalVolChanges
 */
export interface TotalVolChanges {
    /**
     * Sum of \"rune_amount\" of buy swap events
     * @type {string}
     * @memberof TotalVolChanges
     */
    buyVolume?: string;
    /**
     * Sum of \"rune_amount\" of sell swap events
     * @type {string}
     * @memberof TotalVolChanges
     */
    sellVolume?: string;
    /**
     * Determining end of current time bucket in unix timestamp
     * @type {number}
     * @memberof TotalVolChanges
     */
    time?: number;
    /**
     * buyVolume + sellVolume
     * @type {string}
     * @memberof TotalVolChanges
     */
    totalVolume?: string;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    address?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    coins?: Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    txID?: string;
}
/**
 * 
 * @export
 * @interface TxDetails
 */
export interface TxDetails {
    /**
     * 
     * @type {number}
     * @memberof TxDetails
     */
    date?: number;
    /**
     * 
     * @type {Event}
     * @memberof TxDetails
     */
    events?: Event;
    /**
     * 
     * @type {Gas}
     * @memberof TxDetails
     */
    gas?: Gas;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    height?: string;
    /**
     * 
     * @type {Tx}
     * @memberof TxDetails
     */
    in?: Tx;
    /**
     * 
     * @type {Option}
     * @memberof TxDetails
     */
    options?: Option;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxDetails
     */
    out?: Array<Tx>;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    status?: TxDetailsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    type?: TxDetailsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TxDetailsStatusEnum {
    Success = 'success',
    Refund = 'refund'
}
/**
    * @export
    * @enum {string}
    */
export enum TxDetailsTypeEnum {
    Swap = 'swap',
    Stake = 'stake',
    Unstake = 'unstake',
    Rewards = 'rewards',
    Add = 'add',
    Pool = 'pool',
    Gas = 'gas',
    Refund = 'refund',
    DoubleSwap = 'doubleSwap'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInfo(asset: string, options: any = {}): RequestArgs {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling getAssetInfo.');
            }
            const localVarPath = `/v1/assets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options: any = {}): RequestArgs {
            const localVarPath = `/v1/health`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options: any = {}): RequestArgs {
            const localVarPath = `/v1/network`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options: any = {}): RequestArgs {
            const localVarPath = `/v1/nodes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options: any = {}): RequestArgs {
            // verify required parameter 'pool' is not null or undefined
            if (pool === null || pool === undefined) {
                throw new RequiredError('pool','Required parameter pool was null or undefined when calling getPoolAggChanges.');
            }
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError('interval','Required parameter interval was null or undefined when calling getPoolAggChanges.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getPoolAggChanges.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getPoolAggChanges.');
            }
            const localVarPath = `/v1/history/pools`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(options: any = {}): RequestArgs {
            const localVarPath = `/v1/pools`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options: any = {}): RequestArgs {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling getPoolsDetails.');
            }
            const localVarPath = `/v1/pools/detail`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressAndAssetData(address: string, asset: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getStakersAddressAndAssetData.');
            }
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new RequiredError('asset','Required parameter asset was null or undefined when calling getStakersAddressAndAssetData.');
            }
            const localVarPath = `/v1/stakers/{address}/pools`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressData(address: string, options: any = {}): RequestArgs {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling getStakersAddressData.');
            }
            const localVarPath = `/v1/stakers/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersData(options: any = {}): RequestArgs {
            const localVarPath = `/v1/stakers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options: any = {}): RequestArgs {
            const localVarPath = `/v1/stats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedConstants(options: any = {}): RequestArgs {
            const localVarPath = `/v1/thorchain/constants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedEndpoints(options: any = {}): RequestArgs {
            const localVarPath = `/v1/thorchain/pool_addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedLastblock(options: any = {}): RequestArgs {
            const localVarPath = `/v1/thorchain/lastblock`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options: any = {}): RequestArgs {
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError('interval','Required parameter interval was null or undefined when calling getTotalVolChanges.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getTotalVolChanges.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling getTotalVolChanges.');
            }
            const localVarPath = `/v1/history/total_volume`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options: any = {}): RequestArgs {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling getTxDetails.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getTxDetails.');
            }
            const localVarPath = `/v1/txs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInfo(asset: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetDetail>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getAssetInfo(asset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getHealth(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkInfo> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getNetworkData(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeKey>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getNodes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PoolAggChanges>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getPoolAggChanges(pool, interval, from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getPools(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PoolDetail>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getPoolsDetails(asset, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressAndAssetData(address: string, asset: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StakersAssetData>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getStakersAddressAndAssetData(address, asset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressData(address: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakersAddressData> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getStakersAddressData(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersData(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getStakersData(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsData> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getStats(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedConstants(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainConstants> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getThorchainProxiedConstants(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedEndpoints(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainEndpoints> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getThorchainProxiedEndpoints(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedLastblock(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainLastblock> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getThorchainProxiedLastblock(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TotalVolChanges>> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getTotalVolChanges(interval, from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).getTxDetails(offset, limit, address, txid, asset, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInfo(asset: string, options?: any): AxiosPromise<Array<AssetDetail>> {
            return DefaultApiFp(configuration).getAssetInfo(asset, options)(axios, basePath);
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getHealth(options)(axios, basePath);
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options?: any): AxiosPromise<NetworkInfo> {
            return DefaultApiFp(configuration).getNetworkData(options)(axios, basePath);
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): AxiosPromise<Array<NodeKey>> {
            return DefaultApiFp(configuration).getNodes(options)(axios, basePath);
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): AxiosPromise<Array<PoolAggChanges>> {
            return DefaultApiFp(configuration).getPoolAggChanges(pool, interval, from, to, options)(axios, basePath);
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(options?: any): AxiosPromise<Array<string>> {
            return DefaultApiFp(configuration).getPools(options)(axios, basePath);
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any): AxiosPromise<Array<PoolDetail>> {
            return DefaultApiFp(configuration).getPoolsDetails(asset, view, options)(axios, basePath);
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressAndAssetData(address: string, asset: string, options?: any): AxiosPromise<Array<StakersAssetData>> {
            return DefaultApiFp(configuration).getStakersAddressAndAssetData(address, asset, options)(axios, basePath);
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressData(address: string, options?: any): AxiosPromise<StakersAddressData> {
            return DefaultApiFp(configuration).getStakersAddressData(address, options)(axios, basePath);
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersData(options?: any): AxiosPromise<Array<string>> {
            return DefaultApiFp(configuration).getStakersData(options)(axios, basePath);
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<StatsData> {
            return DefaultApiFp(configuration).getStats(options)(axios, basePath);
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedConstants(options?: any): AxiosPromise<ThorchainConstants> {
            return DefaultApiFp(configuration).getThorchainProxiedConstants(options)(axios, basePath);
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedEndpoints(options?: any): AxiosPromise<ThorchainEndpoints> {
            return DefaultApiFp(configuration).getThorchainProxiedEndpoints(options)(axios, basePath);
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedLastblock(options?: any): AxiosPromise<ThorchainLastblock> {
            return DefaultApiFp(configuration).getThorchainProxiedLastblock(options)(axios, basePath);
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): AxiosPromise<Array<TotalVolChanges>> {
            return DefaultApiFp(configuration).getTotalVolChanges(interval, from, to, options)(axios, basePath);
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).getTxDetails(offset, limit, address, txid, asset, type, options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
     * @summary Get Asset Information
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAssetInfo(asset: string, options?: any) {
        return DefaultApiFp(this.configuration).getAssetInfo(asset, options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing the health response of the API.
     * @summary Get Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: any) {
        return DefaultApiFp(this.configuration).getHealth(options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing Network data
     * @summary Get Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNetworkData(options?: any) {
        return DefaultApiFp(this.configuration).getNetworkData(options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing Node public keys
     * @summary Get Node public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNodes(options?: any) {
        return DefaultApiFp(this.configuration).getNodes(options)(this.axios, this.basePath);
    }

    /**
     * Returns historical aggregated details of the specified pool.
     * @summary Get Pool Aggregated Changes
     * @param {string} pool Pool asset name
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
     * @param {number} from Start time of the query as unix timestamp
     * @param {number} to End time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any) {
        return DefaultApiFp(this.configuration).getPoolAggChanges(pool, interval, from, to, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array containing all the assets supported on BEPSwap pools
     * @summary Get Asset Pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPools(options?: any) {
        return DefaultApiFp(this.configuration).getPools(options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing all the pool details for that asset.
     * @summary Get Pools Details
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any) {
        return DefaultApiFp(this.configuration).getPoolsDetails(asset, view, options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing staking data for the specified staker and pool.
     * @summary Get Staker Pool Data
     * @param {string} address Unique staker address
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersAddressAndAssetData(address: string, asset: string, options?: any) {
        return DefaultApiFp(this.configuration).getStakersAddressAndAssetData(address, asset, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array containing all the pools the staker is staking in.
     * @summary Get Staker Data
     * @param {string} address Unique staker address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersAddressData(address: string, options?: any) {
        return DefaultApiFp(this.configuration).getStakersAddressData(address, options)(this.axios, this.basePath);
    }

    /**
     * Returns an array containing the addresses for all stakers.
     * @summary Get Stakers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersData(options?: any) {
        return DefaultApiFp(this.configuration).getStakersData(options)(this.axios, this.basePath);
    }

    /**
     * Returns an object containing global stats for all pools and all transactions.
     * @summary Get Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStats(options?: any) {
        return DefaultApiFp(this.configuration).getStats(options)(this.axios, this.basePath);
    }

    /**
     * Returns a proxied endpoint for the constants endpoint from a local thornode
     * @summary Get the Proxied THORChain Constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedConstants(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedConstants(options)(this.axios, this.basePath);
    }

    /**
     * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
     * @summary Get the Proxied Pool Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedEndpoints(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedEndpoints(options)(this.axios, this.basePath);
    }

    /**
     * Returns a proxied endpoint for the lastblock endpoint from a local thornode
     * @summary Get the Proxied THORChain Lastblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedLastblock(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedLastblock(options)(this.axios, this.basePath);
    }

    /**
     * Returns total volume changes of all pools in specified interval
     * @summary Get Total Volume Changes
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
     * @param {number} from Start time of the query as unix timestamp
     * @param {number} to End time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any) {
        return DefaultApiFp(this.configuration).getTotalVolChanges(interval, from, to, options)(this.axios, this.basePath);
    }

    /**
     * Return an array containing the event details
     * @summary Get details of a tx by address, asset or tx-id
     * @param {number} offset pagination offset
     * @param {number} limit pagination limit
     * @param {string} [address] Address of sender or recipient of any in/out tx in event
     * @param {string} [txid] ID of any in/out tx in event
     * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
     * @param {string} [type] One or more comma separated unique types of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTxDetails(offset, limit, address, txid, asset, type, options)(this.axios, this.basePath);
    }

}


/**
 * DocumentationApi - axios parameter creator
 * @export
 */
export const DocumentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options: any = {}): RequestArgs {
            const localVarPath = `/v1/doc`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentationApi - functional programming interface
 * @export
 */
export const DocumentationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DocumentationApiAxiosParamCreator(configuration).getDocs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DocumentationApi - factory interface
 * @export
 */
export const DocumentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options?: any): AxiosPromise<void> {
            return DocumentationApiFp(configuration).getDocs(options)(axios, basePath);
        },
    };
};

/**
 * DocumentationApi - object-oriented interface
 * @export
 * @class DocumentationApi
 * @extends {BaseAPI}
 */
export class DocumentationApi extends BaseAPI {
    /**
     * Swagger/openapi 3.0 specification generated documents.
     * @summary Get Documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getDocs(options?: any) {
        return DocumentationApiFp(this.configuration).getDocs(options)(this.axios, this.basePath);
    }

}


/**
 * SpecificationApi - axios parameter creator
 * @export
 */
export const SpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options: any = {}): RequestArgs {
            const localVarPath = `/v1/swagger.json`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecificationApi - functional programming interface
 * @export
 */
export const SpecificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = SpecificationApiAxiosParamCreator(configuration).getSwagger(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SpecificationApi - factory interface
 * @export
 */
export const SpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options?: any): AxiosPromise<void> {
            return SpecificationApiFp(configuration).getSwagger(options)(axios, basePath);
        },
    };
};

/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
export class SpecificationApi extends BaseAPI {
    /**
     * Returns human and machine readable swagger/openapi specification.
     * @summary Get Swagger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getSwagger(options?: any) {
        return SpecificationApiFp(this.configuration).getSwagger(options)(this.axios, this.basePath);
    }

}


